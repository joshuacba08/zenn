---
title: "¬øEst√°s aplicando un anti-patr√≥n de arquitectura en el Frontend?"
emoji: "üò∏"
type: "tech, idea" # tech: ÊäÄË°ìË®ò‰∫ã / idea: „Ç¢„Ç§„Éá„Ç¢
topics: [architecture, frontend, anti-pattern, programming, web-development]
published: false
---
Al iniciar un proyecto tanto en el Frontend como en el Backend, generalmente definimos muchos aspectos de nuestro software de acuerdo a los requerimientos que se nos piden. Sin embargo, con el tiempo el proyecto crece y se vuelve m√°s complejo, y es aqu√≠ donde pueden aparecer los anti-patrones de arquitectura. En este art√≠culo veremos algunos puntos que pueden diagnosticar que estamos aplicando un anti-patr√≥n de arquitectura en el Frontend sin saberlo.

![1733810370549](image/dd48e621df6f51/1733810370549.png)

## ¬øQu√© es y por qu√© es importante la arquitectura en el Frontend?

Antes que nada, me gustar√≠a definir un poco acerca de lo que significa `arquitectura` en el desarrollo de software. Si eres nuevo en el mundo de la programaci√≥n, es posible que hayas escuchado este t√©rmino pero no sepas exactamente a qu√© se refiere. En palabras simples, una arquitectura en el desarrollo de software es la estructura que define c√≥mo se organizar√°n los diferentes componentes de un sistema y c√≥mo interactuar√°n entre s√≠. Adem√°s, la arquitectura define las reglas y los principios que guiar√°n el desarrollo del software.

Una **buena arquitectura es fundamental para aplicar y mantener un buen flujo de trabajo para todos los desarrolladores implicados en el proyecto**, as√≠ como tambi√©n facilita que nuevos equipos o miembros se sumen al proyecto sin mayores problemas. Adem√°s, una correcta arquitectura hace que la base de c√≥digo sea m√°s mantenible, escalable y testeable. En pocas palabras, **incrementa la calidad del software y la productividad de los equipos de desarrollo**.

## Del otro lado del r√≠o: los anti-patrones de arquitectura

Luego de la breve explicaci√≥n acerca de aplicar una buena arquitectura en el Frontend, es importante hacer una contraposici√≥n con los anti-patrones de arquitectura. Para eso aplicaremos una hip√≥tesis con su respectiva contra-hip√≥tesis para entender mejor el concepto:

- **Hip√≥tesis**: "Una buena arquitectura mantiene un buen flujo de trabajo para todo el equipo de desarrollo".
- **Contra-hip√≥tesis**: "Un anti-patr√≥n de arquitectura puede generar un mal flujo de trabajo para todo el equipo de desarrollo".

- **Hip√≥tesis**: "Una buena arquitectura facilita la incorporaci√≥n de nuevos miembros al equipo de desarrollo".
- **Contra-hip√≥tesis**: "Un anti-patr√≥n de arquitectura puede dificultar la incorporaci√≥n de nuevos miembros al equipo de desarrollo".

- **Hip√≥tesis**: "Una buena arquitectura hace que la base de c√≥digo sea m√°s mantenible, escalable y testeable".
- **Contra-hip√≥tesis**: "Un anti-patr√≥n de arquitectura puede hacer que la base de c√≥digo sea menos mantenible, escalable y testeable".

- **Hip√≥tesis**: "Una buena arquitectura incrementa la calidad del software y la productividad de los equipos de desarrollo".
- **Contra-hip√≥tesis**: "Un anti-patr√≥n de arquitectura puede disminuir la calidad del software y la productividad de los equipos de desarrollo".

Sinceramente, la primera vez que me plati√© estos puntos, qued√© sorprendido por lo mal que se oyen las contra-hip√≥tesis. Sin embargo, es importante tener en cuenta que **los anti-patrones de arquitectura pueden aparecer en cualquier proyecto sin que nos demos cuenta**. Por eso, es importante estar atentos a ciertos puntos que pueden diagnosticar que estamos aplicando un anti-patr√≥n de arquitectura en el Frontend.

## ¬øEst√°s aplicando un anti-patr√≥n de arquitectura en el Frontend?

Los anti-patrones de arquitectura no son algo que se aplique de manera intencional, sin embargo, ning√∫n proyecto est√° exento de ellos. A continuaci√≥n, veremos algunos puntos que pueden diagnosticar que estamos aplicando un anti-patr√≥n de arquitectura en el Frontend sin saberlo:

### No separar la l√≥gica de negocio de la interfaz de usuario

Uno de los anti-patrones de arquitectura m√°s comunes en el Frontend es no separar la l√≥gica de negocio de la interfaz de usuario. Este anti-patr√≥n se conoce como `Spaghetti Code` y se caracteriza por tener una base de c√≥digo desorganizada, dif√≠cil de mantener y de entender. En este anti-patr√≥n, la l√≥gica de negocio y la interfaz de usuario est√°n mezcladas, lo que hace que sea dif√≠cil de testear y de escalar.

#### ¬øQu√© conocemos como l√≥gica de negocio?

La l√≥gica de negocio es el conjunto de reglas y procesos que definen c√≥mo se realizar√°n las operaciones de un sistema. En el Frontend, la l√≥gica de negocio se encarga de procesar los datos y de realizar las operaciones necesarias para que la interfaz de usuario funcione correctamente. Por ejemplo, si estamos desarrollando una aplicaci√≥n de carrito de compras, la l√≥gica de negocio se encargar√° de sumar los precios de los productos, de calcular el total de la compra y de aplicar los descuentos correspondientes.

#### ¬øQu√© conocemos como interfaz de usuario?

La interfaz de usuario es la parte visual de una aplicaci√≥n que interact√∫a con el usuario. En el Frontend, la interfaz de usuario se encarga de mostrar los datos y de permitir que el usuario interact√∫e con la aplicaci√≥n. Por ejemplo, si estamos desarrollando una aplicaci√≥n de carrito de compras, la interfaz de usuario se encargar√° de mostrar los productos, de permitir que el usuario seleccione los productos que desea comprar y de mostrar el total de la compra.

#### Soluci√≥n: separar la l√≥gica de negocio de la interfaz de usuario

Para evitar caer en el anti-patr√≥n de no separar la l√≥gica de negocio de la interfaz de usuario, es importante seguir el principio de `Separation of Concerns` (Separaci√≥n de Responsabilidades). Este principio consiste en separar las diferentes responsabilidades de un sistema en m√≥dulos independientes, de manera que cada m√≥dulo se encargue de una sola responsabilidad y que cada responsabilidad est√© separada de las dem√°s.

En React JS podemos aplicar este principio utilizando `Hooks` y `Context API` para separar la l√≥gica de negocio de la interfaz de usuario. Por ejemplo, podemos crear un `Hook` que se encargue de manejar la l√≥gica de negocio de una aplicaci√≥n de carrito de compras y un `Context` que se encargue de manejar la interfaz de usuario de la aplicaci√≥n. De esta manera, podremos separar las diferentes responsabilidades de la aplicaci√≥n y evitar caer en el anti-patr√≥n de no separar la l√≥gica de negocio de la interfaz de usuario. Tambi√©n podemos aplicar el concepto de componentes `Presentational` y `Smart` para separar la l√≥gica de presentaci√≥n de la l√≥gica de negocio.

### No utilizar un patr√≥n de arquitectura (condici√≥n necesaria pero no suficiente)

En mi experiencia he tenido la suerte de conocer a muchos desarrolladores habilidosos que sin tener en cuenta los patrones de arquitectura han aplicado de manera intuitiva una buena arquitectura en sus proyectos. Sin embargo, **no utilizar un patr√≥n de arquitectura puede ser un indicio de que estamos aplicando un anti-patr√≥n de arquitectura en el Frontend**. Es decir, no utilizar un patr√≥n de arquitectura no es suficiente para diagnosticar que estamos aplicando un anti-patr√≥n de arquitectura, pero es una condici√≥n necesaria que predispone a que aparezcan los anti-patrones.

#### Soluci√≥n: utilizar un patr√≥n de arquitectura para una primera aproximaci√≥n

No todo est√° escrito en piedra, puedes aplicar un patr√≥n de arquitectura en un determinado momento de tu aplicaci√≥n y luego ir adapt√°ndolo a tus necesidades. Algunos de los patrones de arquitectura m√°s utilizados en el Frontend son `MVC` (Model-View-Controller), `MVVM` (Model-View-ViewModel) y `Flux`. Cada uno de estos patrones tiene sus propias ventajas y desventajas, por lo que es importante evaluar cu√°l es el m√°s adecuado para tu proyecto.

### No aplicar buenas pr√°cticas de programaci√≥n

Este quiz√° es un punto muy controversial ya que las `buenas pr√°cticas de programaci√≥n` pueden variar de un desarrollador a otro y en muchos casos ser subjetivas. Sin embargo, el simple hecho de que el desarrollador o el equipo se plantee aplicar buenas pr√°cticas de programaci√≥n ya es un indicio de que est√°n preocupados por la calidad del software y la productividad del equipo.

#### Soluci√≥n: definir una gu√≠a de estilo de c√≥digo validada por todo el equipo

Personalmente, m√°s all√° de lo que est√° escrito en libros y art√≠culos, considero que las buenas pr√°cticas son un concenso entre los miembros del equipo. Por eso, es importante sentarse a discutir y definir una gu√≠a de estilo con la que todo el equipo se sienta c√≥modo.

Evita las discusiones interminables sobre si se deben utilizar `tabs` o `espacios`, `punto y coma` o `no punto y coma`, `camelCase` o `snake_case`. Define una gu√≠a de estilo que sea clara, concisa y que se adapte a las necesidades del equipo. Puedes utilizar herramientas como `ESLint` y `Prettier` para automatizar la aplicaci√≥n de la gu√≠a de estilo y evitar discusiones innecesarias. Adem√°s, puedes utilizar herramientas como `Husky` y `Lint-Staged` para prevenir que se suban cambios que no cumplan con la gu√≠a de estilo.

## Conclusi√≥n

Antes que nada, si has llegado hasta ac√° te quiero agradecer por haber le√≠do este art√≠culo. Espero que te haya sido de utilidad o de tu agrado. No dudes en dejarme un comentario si tienes alguna duda o sugerencia.

Quiero terminar con un gr√°fico que guarda relaci√≥n 

