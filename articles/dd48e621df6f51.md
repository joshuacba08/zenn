---
title: "¬øEst√°s aplicando un anti-patr√≥n de arquitectura en el Frontend?"
emoji: "üèóÔ∏è"
type: "tech" # tech: ÊäÄË°ìË®ò‰∫ã / idea: „Ç¢„Ç§„Éá„Ç¢
topics: [architecture, frontend, antipattern, programming, webdevelopment]
published: true
---

Al iniciar un proyecto tanto en el Frontend como en el Backend, generalmente definimos muchos aspectos de nuestro software de acuerdo a los requerimientos que se nos piden. Sin embargo, con el tiempo el proyecto crece y se vuelve m√°s complejo, y es aqu√≠ donde pueden aparecer los **anti-patrones de arquitectura**. En este art√≠culo veremos algunos puntos que pueden diagnosticar que estamos aplicando un anti-patr√≥n de arquitectura en el Frontend sin saberlo, y lo m√°s importante: **c√≥mo solucionarlos**.

![Portada](https://res.cloudinary.com/dvgro0geg/image/upload/v1767802011/assets/articles_devto/Gemini_Generated_Image_rnxivfrnxivfrnxi_1_lashdv.png)

## ¬øQu√© es y por qu√© es importante la arquitectura en el Frontend?

Antes que nada, me gustar√≠a definir un poco acerca de lo que significa `arquitectura` en el desarrollo de software. Si eres nuevo en el mundo de la programaci√≥n, es posible que hayas escuchado este t√©rmino pero no sepas exactamente a qu√© se refiere.

> **Arquitectura de software** es la estructura de alto nivel de un sistema de software, la disciplina de crear tales estructuras, y la documentaci√≥n de estas estructuras. ‚Äî *Software Architecture in Practice, Bass et al.*

En palabras simples, una arquitectura en el desarrollo de software es la estructura que define c√≥mo se organizar√°n los diferentes componentes de un sistema y c√≥mo interactuar√°n entre s√≠. Adem√°s, la arquitectura define las reglas y los principios que guiar√°n el desarrollo del software.

```mermaid
flowchart LR
    subgraph Arquitectura["Arquitectura de Software"]
        direction TB
        E["Estructura"] --> C["Componentes"]
        C --> I["Interacciones"]
        I --> R["Reglas y Principios"]
    end
    
    Arquitectura --> Beneficios
    
    subgraph Beneficios["Beneficios"]
        direction TB
        M["Mantenibilidad"]
        S["Escalabilidad"]
        T["Testeabilidad"]
        PR["Productividad"]
    end
    
    M --> Equipo
    S --> Equipo
    T --> Equipo
    PR --> Equipo
    
    Equipo["Equipos de desarrollo\nm√°s eficientes"]
```

Una **buena arquitectura es fundamental para aplicar y mantener un buen flujo de trabajo para todos los desarrolladores implicados en el proyecto**, as√≠ como tambi√©n facilita que nuevos equipos o miembros se sumen al proyecto sin mayores problemas. Adem√°s, una correcta arquitectura hace que la base de c√≥digo sea m√°s mantenible, escalable y testeable. En pocas palabras, **incrementa la calidad del software y la productividad de los equipos de desarrollo**.

### Los pilares de una buena arquitectura Frontend

Para entender mejor qu√© hace que una arquitectura sea "buena", veamos sus pilares fundamentales:

| Pilar | Descripci√≥n | Ejemplo pr√°ctico |
|-------|-------------|------------------|
| **Separaci√≥n de responsabilidades** | Cada m√≥dulo tiene una √∫nica responsabilidad | Componentes UI separados de la l√≥gica de negocio |
| **Bajo acoplamiento** | Los m√≥dulos dependen lo menos posible entre s√≠ | Usar interfaces y abstracciones |
| **Alta cohesi√≥n** | Elementos relacionados est√°n agrupados | Features o dominios bien definidos |
| **Escalabilidad** | El sistema puede crecer sin reestructuraci√≥n mayor | Arquitectura modular |
| **Testeabilidad** | Facilidad para escribir y ejecutar tests | Dependencias inyectables |

![pilares_arquitectura](https://res.cloudinary.com/dvgro0geg/image/upload/v1767801400/assets/articles_devto/image_ouer5n.png)
## Del otro lado del r√≠o: los anti-patrones de arquitectura

Luego de la breve explicaci√≥n acerca de aplicar una buena arquitectura en el Frontend, es importante hacer una contraposici√≥n con los anti-patrones de arquitectura.

> Un **anti-patr√≥n** es una respuesta com√∫n a un problema recurrente que es usualmente inefectiva y tiene el riesgo de ser altamente contraproducente. ‚Äî *AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis*

Para entender mejor el concepto, aplicaremos una hip√≥tesis con su respectiva contra-hip√≥tesis:

```mermaid
flowchart LR
    subgraph Buena["Buena Arquitectura"]
        B1["Buen flujo de trabajo"]
        B2["F√°cil onboarding"]
        B3["C√≥digo mantenible"]
        B4["Alta productividad"]
    end
    
    subgraph Mala["Anti-patr√≥n"]
        M1["Mal flujo de trabajo"]
        M2["Dif√≠cil onboarding"]
        M3["C√≥digo fr√°gil"]
        M4["Baja productividad"]
    end
    
    B1 <-.->|vs| M1
    B2 <-.->|vs| M2
    B3 <-.->|vs| M3
    B4 <-.->|vs| M4
```

- **Hip√≥tesis**: "Una buena arquitectura mantiene un buen flujo de trabajo para todo el equipo de desarrollo".
- **Contra-hip√≥tesis**: "Un anti-patr√≥n de arquitectura puede generar un mal flujo de trabajo para todo el equipo de desarrollo".

- **Hip√≥tesis**: "Una buena arquitectura facilita la incorporaci√≥n de nuevos miembros al equipo de desarrollo".
- **Contra-hip√≥tesis**: "Un anti-patr√≥n de arquitectura puede dificultar la incorporaci√≥n de nuevos miembros al equipo de desarrollo".

- **Hip√≥tesis**: "Una buena arquitectura hace que la base de c√≥digo sea m√°s mantenible, escalable y testeable".
- **Contra-hip√≥tesis**: "Un anti-patr√≥n de arquitectura puede hacer que la base de c√≥digo sea menos mantenible, escalable y testeable".

- **Hip√≥tesis**: "Una buena arquitectura incrementa la calidad del software y la productividad de los equipos de desarrollo".
- **Contra-hip√≥tesis**: "Un anti-patr√≥n de arquitectura puede disminuir la calidad del software y la productividad de los equipos de desarrollo".

Sinceramente, la primera vez que me plante√© estos puntos, qued√© sorprendido por lo mal que se oyen las contra-hip√≥tesis. Sin embargo, es importante tener en cuenta que **los anti-patrones de arquitectura pueden aparecer en cualquier proyecto sin que nos demos cuenta**. Por eso, es importante estar atentos a ciertos puntos que pueden diagnosticar que estamos aplicando un anti-patr√≥n de arquitectura en el Frontend.

## ¬øEst√°s aplicando un anti-patr√≥n de arquitectura en el Frontend?

Los anti-patrones de arquitectura no son algo que se aplique de manera intencional, sin embargo, ning√∫n proyecto est√° exento de ellos. A continuaci√≥n, veremos los anti-patrones m√°s comunes en el desarrollo Frontend y c√≥mo identificarlos:

### 1. El "Spaghetti Code" o la Gran Bola de Lodo (Big Ball of Mud)

Este es probablemente el anti-patr√≥n m√°s com√∫n y peligroso. Se caracteriza por una falta total de estructura visible, donde el c√≥digo crece de manera org√°nica y desordenada.

```mermaid
flowchart TD
    subgraph Spaghetti["Big Ball of Mud"]
        A["ComponenteA"] --> B["ComponenteB"]
        B --> C["ComponenteC"]
        C --> A
        A --> D["ComponenteD"]
        D --> B
        C --> D
        B --> A
        D --> C
        A --> C
    end
```

**S√≠ntomas:**
- No existe una separaci√≥n clara de capas
- Componentes con m√∫ltiples responsabilidades (m√°s de 500 l√≠neas)
- Dependencias circulares entre m√≥dulos
- Dificultad para encontrar d√≥nde est√° la l√≥gica de una funcionalidad
- Los cambios en un lugar rompen funcionalidades en otros lugares

**Soluci√≥n:**

```mermaid
flowchart TB
    subgraph Clean["Arquitectura Limpia"]
        direction TB
        subgraph UI["Capa de Presentaci√≥n"]
            V["Views/Pages"]
            C["Components"]
        end
        
        subgraph Logic["Capa de L√≥gica"]
            H["Hooks/Composables"]
            S["Services"]
        end
        
        subgraph Data["Capa de Datos"]
            R["Repositories"]
            A["API Clients"]
        end
    end
    
    V --> H
    C --> H
    H --> S
    S --> R
    R --> A
```

### 2. El Componente Dios (God Component)

Un componente que hace demasiadas cosas: maneja estado, hace llamadas a APIs, contiene l√≥gica de negocio, y renderiza UI compleja.

![god_component](https://res.cloudinary.com/dvgro0geg/image/upload/v1767741837/assets/articles_devto/Gemini_Generated_Image_4q7oa4q7oa4q7oa4_bz6sfy.png)



**Ejemplo de un God Component (Mal):**

```jsx
// UserDashboard.jsx - 800+ l√≠neas
function UserDashboard() {
  const [user, setUser] = useState(null);
  const [orders, setOrders] = useState([]);
  const [notifications, setNotifications] = useState([]);
  const [settings, setSettings] = useState({});
  const [isLoading, setIsLoading] = useState(true);
  // ... 50 m√°s estados
  
  useEffect(() => {
    // Fetch user, orders, notifications, settings...
    // L√≥gica de transformaci√≥n de datos
    // Manejo de errores
    // WebSocket connections
  }, [/* muchas dependencias */]);
  
  const handleUpdateProfile = async () => { /* ... */ };
  const handleDeleteOrder = async () => { /* ... */ };
  const handleMarkNotificationRead = async () => { /* ... */ };
  // ... 30 m√°s handlers
  
  return (
    // 500+ l√≠neas de JSX
  );
}
```

**Soluci√≥n - Composici√≥n y separaci√≥n:**

```mermaid
flowchart TB
    GC["God Component"] -->|Refactorizar| SC["Componentes Especializados"]
    
    subgraph SC["Componentes Especializados"]
        UP["UserProfile"]
        OL["OrdersList"]
        NP["NotificationsPanel"]
        SP["SettingsPanel"]
    end
    
    subgraph Hooks["Custom Hooks"]
        UH["useUser()"]
        OH["useOrders()"]
        NH["useNotifications()"]
        SH["useSettings()"]
    end
    
    UP --> UH
    OL --> OH
    NP --> NH
    SP --> SH
```

### 3. Acoplamiento Excesivo (Tight Coupling)

Cuando los componentes o m√≥dulos dependen demasiado de la implementaci√≥n interna de otros, cualquier cambio se convierte en una pesadilla.

```mermaid
flowchart LR
    subgraph Coupled["Alto Acoplamiento"]
        CA["ComponenteA"] -->|conoce internals| CB["ComponenteB"]
        CB -->|conoce internals| CC["ComponenteC"]
        CC -->|conoce internals| CA
    end
```

**S√≠ntomas:**
- Cambiar un componente requiere modificar muchos otros
- Los tests requieren mockear muchas dependencias
- Componentes importan directamente de rutas profundas de otros m√≥dulos
- Props drilling excesivo (pasar props a trav√©s de 5+ niveles)

**Soluci√≥n - Inversi√≥n de dependencias:**

```mermaid
flowchart TB
    subgraph Decoupled["Bajo Acoplamiento"]
        CA2["ComponenteA"]
        CB2["ComponenteB"]
        CC2["ComponenteC"]
        
        subgraph Contracts["Contratos/Interfaces"]
            I1["Interface A"]
            I2["Interface B"]
        end
    end
    
    CA2 -->|usa| I1
    CB2 -->|implementa| I1
    CB2 -->|usa| I2
    CC2 -->|implementa| I2
```

### 4. La Carpeta "Utils" o "Helpers" Infinita

Una carpeta que se convierte en el caj√≥n de sastre donde va todo lo que "no sabemos d√≥nde poner".

![utils_folder](https://res.cloudinary.com/dvgro0geg/image/upload/v1767794884/assets/articles_devto/Gemini_Generated_Image_ngsxsungsxsungsx_1_c3ybbq.png)

**Estructura problem√°tica (Mal):**

```
src/
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ helpers.js          # 2000 l√≠neas
‚îÇ   ‚îú‚îÄ‚îÄ functions.js        # 1500 l√≠neas
‚îÇ   ‚îú‚îÄ‚îÄ misc.js             # ???
‚îÇ   ‚îú‚îÄ‚îÄ common.js           # M√°s de lo mismo
‚îÇ   ‚îî‚îÄ‚îÄ index.js            # Re-exporta todo
```

**Soluci√≥n - Organizaci√≥n por dominio:**

```mermaid
flowchart TB
    subgraph Before["Antes"]
        U["utils/"]
        U --> H["helpers.js"]
        U --> F["functions.js"]
        U --> M["misc.js"]
    end
    
    subgraph After["Despu√©s"]
        direction TB
        D1["date/"]
        D1 --> D1F["formatters.ts"]
        D1 --> D1V["validators.ts"]
        
        D2["currency/"]
        D2 --> D2F["formatters.ts"]
        D2 --> D2C["converters.ts"]
        
        D3["validation/"]
        D3 --> D3S["schemas.ts"]
        D3 --> D3R["rules.ts"]
    end
```

### 5. El Estado Global Descontrolado (Global State Soup)

Usar estado global para todo, incluso para estado que deber√≠a ser local.

```mermaid
flowchart TD
    subgraph GlobalSoup["Global State Soup"]
        GS["Estado Global Gigante"]
        GS --> U["userData"]
        GS --> F["formState"]
        GS --> M["modalOpen"]
        GS --> T["tempValues"]
        GS --> UI["uiPreferences"]
        GS --> C["cache"]
    end
    
    CA["Cualquier Componente"] --> GS
```

**S√≠ntomas:**
- El store global tiene cientos de propiedades
- Estado de formularios en Redux/Zustand
- Valores temporales o de UI en estado global
- Dificultad para rastrear qu√© modifica qu√©
- Re-renders innecesarios en toda la aplicaci√≥n

**Soluci√≥n - Separaci√≥n de responsabilidades de estado:**

```mermaid
flowchart TB
    subgraph StateStrategy["Estrategia de Estado"]
        subgraph Local["Estado Local"]
            L1["useState - UI temporal"]
            L2["useReducer - L√≥gica compleja local"]
        end
        
        subgraph Server["Estado del Servidor"]
            S1["React Query"]
            S2["SWR"]
            S3["Apollo Client"]
        end
        
        subgraph Global["Estado Global Real"]
            G1["Auth/Session"]
            G2["Theme"]
            G3["Configuraci√≥n App"]
        end
    end
```

### 6. La Abstracci√≥n Prematura (Premature Abstraction)

Crear abstracciones complejas antes de que sean necesarias, "por si acaso". Este es un error com√∫n cuando se intenta aplicar patrones de dise√±o sin una necesidad real, muchas veces motivado por:

- Haber le√≠do recientemente sobre un patr√≥n de dise√±o y querer aplicarlo
- Miedo a tener que refactorizar en el futuro
- Presi√≥n por escribir c√≥digo "profesional" o "escalable"
- No distinguir entre complejidad esencial y complejidad accidental

Debo reconocer que he ca√≠do en este anti-patr√≥n en varias ocasiones cuando a√∫n ten√≠a poca experiencia en desarrollo de software. En alg√∫n momento de mi carrera, me di cuenta que con algunas preguntas simples pod√≠a evitar caer en este anti-patr√≥n:

| Pregunta | Si la respuesta es NO... |
|----------|--------------------------|
| ¬øRealmente necesito esta abstracci√≥n ahora? | Espera a tener el caso de uso real |
| ¬øEstoy resolviendo un problema real o uno hipot√©tico? | No resuelvas problemas que no existen |
| ¬øEsta abstracci√≥n a√±ade valor o solo complejidad? | Mant√©n la soluci√≥n simple |
| ¬øPuedo implementar esto de manera m√°s simple primero? | Hazlo simple y refactoriza despu√©s |

#### La Regla del Tres

Un principio √∫til para decidir cu√°ndo abstraer es la **Regla del Tres**:

```mermaid
flowchart TD
    A["Primera vez: Hazlo funcionar"] --> B["Segunda vez: Nota la similitud"]
    B --> C["Tercera vez: Abstrae"]
    
    subgraph Proceso["Proceso de decisi√≥n"]
        D{"¬øCu√°ntas veces\nhas repetido\neste c√≥digo?"}
        D -->|1 vez| E["Implementa directamente"]
        D -->|2 veces| F["Considera si vale la pena abstraer"]
        D -->|3+ veces| G["Es momento de crear una abstracci√≥n"]
    end
```

#### Ejemplo: Sobre-ingenier√≠a vs. Soluci√≥n pragm√°tica

**Mal - Sobre-ingenier√≠a para un simple bot√≥n:**

```typescript
// 8 archivos, 200+ l√≠neas para... un bot√≥n
interface IButtonStrategy {
  execute(): void;
}

interface IButtonProps {
  strategy: IButtonStrategy;
  builder: IButtonBuilder;
}

class SubmitButtonStrategy implements IButtonStrategy {
  constructor(private validator: IFormValidator) {}
  execute(): void { /* ... */ }
}

class CancelButtonStrategy implements IButtonStrategy { /* ... */ }
class ButtonStrategyFactory { /* ... */ }
class ButtonBuilder implements IButtonBuilder { /* ... */ }
class AbstractButton extends BaseComponent { /* ... */ }

// Para al final renderizar:
// <button onClick={strategy.execute}>Submit</button>
```

**Bien - Soluci√≥n simple que resuelve el problema real:**

```typescript
// Un componente, ~30 l√≠neas
interface ButtonProps {
  variant: 'submit' | 'cancel' | 'default';
  onClick: () => void;
  children: React.ReactNode;
  disabled?: boolean;
}

function Button({ variant, onClick, children, disabled }: ButtonProps) {
  const styles = {
    submit: 'bg-blue-500 text-white',
    cancel: 'bg-gray-200 text-gray-700',
    default: 'bg-white border border-gray-300',
  };

  return (
    <button 
      className={styles[variant]} 
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
}
```

#### Principios a seguir

> "Make it work, make it right, make it fast" ‚Äî Kent Beck

> "Duplication is far cheaper than the wrong abstraction" ‚Äî Sandi Metz

```mermaid
flowchart LR
    subgraph Evoluci√≥n["Evoluci√≥n del c√≥digo"]
        A["Funciona"] --> B["Es correcto"]
        B --> C["Es r√°pido"]
    end
    
    C --> D{"¬øHay patr√≥n\nrepetido 3+ veces?"}
    D -->|S√≠| E["Identifica la abstracci√≥n correcta"]
    D -->|No| F["Mant√©n simple, no anticipes"]
    
    E --> G["Abstrae con cuidado"]
    F --> H["Revisa en el futuro"]
```

La clave est√° en encontrar el equilibrio: **ni sobre-ingenier√≠a ni c√≥digo duplicado sin sentido**. La abstracci√≥n correcta emerge cuando tienes suficiente contexto sobre el problema real.

### 7. El Copy-Paste Driven Development

Copiar y pegar c√≥digo en lugar de crear abstracciones reutilizables cuando S√ç son necesarias. 

**S√≠ntomas:**
- M√∫ltiples componentes con c√≥digo casi id√©ntico
- Cambios que requieren modificar muchos archivos
- Bugs que se arreglan en un lugar pero persisten en otros

```mermaid
flowchart TB
    subgraph CopyPaste["Copy-Paste"]
        CP1["UserCard.jsx"]
        CP2["AdminCard.jsx"]
        CP3["GuestCard.jsx"]
        
        CP1 -.- |"90% igual"| CP2
        CP2 -.- |"90% igual"| CP3
    end
    
    subgraph DRY["Componente Reutilizable"]
        BC["BaseCard"]
        BC --> V1["variant: user"]
        BC --> V2["variant: admin"]
        BC --> V3["variant: guest"]
    end
```

## Checklist de diagn√≥stico

Utiliza esta checklist para evaluar tu proyecto:

| Pregunta | Bien | Problema |
|----------|---------|-------------|
| ¬øUn nuevo desarrollador puede entender la estructura en < 1 hora? | S√≠ | No |
| ¬øPuedes a√±adir una feature sin modificar c√≥digo existente? | S√≠ | No |
| ¬øLos componentes tienen < 200 l√≠neas de c√≥digo? | Mayor√≠a | Pocos |
| ¬øExiste documentaci√≥n de la arquitectura? | S√≠ | No |
| ¬øLos tests son f√°ciles de escribir? | S√≠ | No |
| ¬øEl estado global tiene < 20 propiedades? | S√≠ | No |
| ¬øLas carpetas utils tienen < 10 archivos? | S√≠ | No |

## El camino hacia una mejor arquitectura

Si identificaste varios de estos anti-patrones en tu proyecto, no te preocupes. La refactorizaci√≥n es un proceso gradual.

```mermaid
flowchart LR
    subgraph Journey["El Camino"]
        A["Identificar anti-patrones"] --> B["Priorizar por impacto"]
        B --> C["Refactorizar incrementalmente"]
        C --> D["Documentar decisiones"]
        D --> E["Establecer gu√≠as"]
        E --> F["Revisar peri√≥dicamente"]
        F --> A
    end
```

### Recomendaciones finales

1. **Documenta tu arquitectura**: Usa ADRs (Architecture Decision Records) para registrar el "por qu√©" de las decisiones.

2. **Establece convenciones**: Define una estructura de carpetas clara y consistente.

3. **Revisa el c√≥digo en equipo**: Los code reviews ayudan a detectar anti-patrones temprano.

4. **Mide y monitorea**: Usa herramientas como SonarQube, ESLint con reglas de complejidad, y m√©tricas de cobertura.

5. **Aprende de otros**: Estudia arquitecturas probadas como Feature-Sliced Design, Atomic Design, o Clean Architecture adaptada a Frontend.



## Conclusi√≥n

Los anti-patrones de arquitectura son como la deuda t√©cnica silenciosa: no los notamos hasta que el proyecto se vuelve dif√≠cil de mantener. La clave est√° en:

- **Detectar temprano**: Revisa regularmente la salud de tu c√≥digo
- **Aprender continuamente**: Estudia patrones de arquitectura
- **Comunicar con el equipo**: Las decisiones de arquitectura son decisiones de equipo
- **Balancear**: Ni sobre-ingenier√≠a ni c√≥digo espagueti

¬øHas identificado alguno de estos anti-patrones en tus proyectos? ¬°Comparte tu experiencia en los comentarios!

---

**Referencias:**

- *Clean Architecture* - Robert C. Martin
- *Patterns of Enterprise Application Architecture* - Martin Fowler
- *AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis* - Brown et al.

---

*¬øTe gust√≥ este art√≠culo? S√≠gueme para m√°s contenido sobre arquitectura Frontend y buenas pr√°cticas de desarrollo.* 